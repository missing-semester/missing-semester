---
layout: lecture
title: "ภาพรวมของคอร์สเรียน + แนะนำให้รู้จักกับ Shell (Course Overview + Introduction to the Shell)"
description: >
    ทำความเข้าใจแรงบันดาลใจเบื้องหลังคอร์สนี้ และเริ่มลงมือลุยใช้งาน shell ไปด้วยกันครับ
thumbnail: /static/assets/thumbnails/2026/lec1.png
date: 2026-01-12
ready: true
video:
    aspect: 56.25
    id: MSgoeuMqUmU
---

# พวกเราคือใคร? (Who are we?)

คลาสนี้สอนร่วมกันโดย [Anish](https://anish.io/), [Jon](https://thesquareplanet.com/), และ [Jose](http://josejg.com/) ครับ พวกเราเป็นศิษย์เก่า MIT ที่ริเริ่มคลาส MIT IAP นี้มาตั้งแต่สมัยยังเป็นนักศึกษา คุณสามารถพูดคุยหรือติดต่อพวกเราแบบเหมารวมได้ที่ [missing-semester@mit.edu](mailto:missing-semester@mit.edu) นะครับ

พวกเราไม่ได้รับค่าตอบแทนจากการสอนคลาสนี้ และไม่ได้หาช่องทางทำเงินจากคลาสนี้เลยแม้แต่น้อย [เนื้อหาของคอร์ส](https://missing.csail.mit.edu/) และ [วิดีโอบันทึกการสอน](https://www.youtube.com/@MissingSemester) ทั้งหมดถูกเปิดให้เข้าถึงได้ฟรีบนช่องทางออนไลน์ ถ้าคุณชอบและอยากสนับสนุนผลงานของเรา วิธีที่ดีที่สุดคือแค่ช่วยบอกต่อหรือแชร์คลาสนี้ให้คนอื่นๆ ได้รับรู้ครับ และถ้าคุณมาจากบริษัท, มหาวิทยาลัย, หรือองค์กรที่นำเนื้อหานี้ไปประยุกต์ใช้สอนคนกลุ่มใหญ่ๆ รบกวนส่งอีเมลมาเล่าประสบการณ์ให้เราฟังหน่อยนะครับ จะดีใจมากเลย :)

# แรงบันดาลใจ (Motivation)

ในฐานะคนสาย Computer Science เราต่างรู้ดีว่าคอมพิวเตอร์เกิดมาเพื่อช่วยเราจัดการกับงานที่ต้องทำซ้ำๆ (repetitive tasks) แต่หลายครั้งที่เรากลับลืมไปว่า กฎข้อนี้มันเอามาใช้กับการ _ใช้งาน_ คอมพิวเตอร์ด้วยเหมือนกัน ไม่ใช่แค่สำหรับการเขียนโปรแกรมหน้าคอมเพียงอย่างเดียว ในทุกวันเรามีเครื่องมือหรือ tools มากมายก่ายกองให้หยิบมาใช้ ซึ่งมันช่วยให้เราทำงานได้ Productive ขึ้นและแก้ปัญหาหน้างานที่ซับซ้อนได้แบบชิลๆ แต่ความเป็นจริงคือ พวกเราหลายคนกลับหยิบ Tools เหล่านี้มาใช้แค่นิดเดียว; เรารู้วิธีสั่งงานแค่พอถูไถให้งานเสร็จไปวันๆ และพอถึงทางตันก็เอาแต่ก็อปปี้คำสั่งจากเน็ตมาวางแบบไม่ได้คิดอะไรต่อ

คลาสนี้สร้างขึ้นมาเพื่อ [จัดการกับปัญหานี้แหละครับ](/about/)

เราอยากสอนให้คุณดึงประสิทธิภาพจาก Tools ที่คุณคุ้นเคยอยู่แล้วออกมาให้สุด, เบิกเนตรพาไปรู้จักกับ Tools ใหม่ๆ เพื่อพกติดตัวเป็นอาวุธเสริม, และหวังลึกๆ ว่ามันจะช่วยจุดประกายความสนุกให้คุณอยากไปงัดแงะ (หรืออาจจะถึงขั้นสร้าง) Tools ใหม่ๆ ด้วยตัวเองต่อไป สิ่งเหล่านี้คือสิ่งที่เราเชื่อสุดใจว่ามันคือ "ภาคการศึกษาที่หล่นหายไป" (the missing semester) ในหลักสูตร Computer Science ทั่วไปครับ

# โครงสร้างคลาสเรียน (Class structure)

คอร์สเรียนแบบไม่เก็บหน่วยกิตนี้ จะประกอบไปด้วยการบรรยาย 9 ครั้ง ครั้งละ 1 ชั่วโมง โดยแต่ละครั้งจะเจาะลึกไปที่ [แต่ละหัวข้อ](/2026/th/) แบบเน้นๆ เนื้อหาในแต่ละเลคเชอร์จะค่อนข้างมีอิสระแยกจากกัน แต่พอเรียนลึกลงไปเรื่อยๆ เราจะถือว่าคุณเริ่มแม่นและจับทางเนื้อหาจากเลคเชอร์แรกๆ ได้แล้วนะครับ เรามี lecture notes แปะไว้ให้อ่านออนไลน์รอล่วงหน้า แต่ในคลาสก็อาจจะมีปล่อยของเพิ่มเติม (เช่น ช่วง Demos ต่างๆ) ที่คุณจะหาไม่ได้จากใน notes แน่นอนว่าเรามีการบันทึกวิดีโอการสอนและทยอยอัปโหลดให้ดูแห้งแบบปีที่ผ่านๆ มาบน [YouTube](https://www.youtube.com/@MissingSemester) ด้วยครับ

เวลาเรามีแค่ไม่กี่ชั่วโมง เราก็เลยตั้งใจจะยัดเนื้อหามาให้ครอบคลุมที่สุดเท่าที่ทำได้ เลคเชอร์ของคอร์สนี้จึงเรียกได้ว่า "อัดแน่น" สุดๆ เพื่อให้คุณมีเวลาทำความคุ้นเคยกับพวกมันตามสปีดของคุณเอง ในแต่ละเลคเชอร์เราเลยจะเหน็บโจทย์แบบฝึกหัด (exercises) มาเป็นไกด์พาคุณลุยทลายจุดสำคัญของเนื้อหานั้นๆ มาด้วย เราอาจจะไม่ได้ตั้งโต๊ะเปิด session Office hours แบบจริงจัง แต่เราขอเชียร์แบบสุดใจให้คุณกล้าขยับไปถามใน [OSSU Discord](https://ossu.dev/#community), โพสต์คำถามทิ้งที่ `#missing-semester-forum`, หรือจะอีเมลตรงมาหาเราที่ [missing-semester@mit.edu](mailto:missing-semester@mit.edu) ได้เลยครับ

ด้วยเวลาที่จำกัด เราคงไม่สามารถพาไปเจาะลึกงัดครอบคลุม Tools แบบละเอียดยิบย่อยเท่ากับคอร์สแบบเต็มเทอมได้ จุดไหนที่เราพอชี้ช่องทางวาปให้คุณไปดำดิ่งขุดลึกต่อได้เราก็จะทำฮะ แต่ถ้ามีเรื่องหัวข้อหรือ Tool ตัวไหนที่คุณรู้สึกคันไม้คันมือสนใจเป็นพิเศษ ก็อย่าได้เกรงใจ แวะมาทักหรือขอคำปรึกษาชี้เป้าจากพวกเราได้เสมอ!

ท้ายสุดนี้ ถ้าคุณมี Feedback หรือคำติชมอะไรเกี่ยวกับคลาส ส่งอีเมลมาหาพวกเราได้เลยที่ [missing-semester@mit.edu](mailto:missing-semester@mit.edu) นะครับ

# หัวข้อที่ 1: แนะนำให้รู้จักกับ Shell (Topic 1: The Shell)

{% comment %}
ผู้สอน: Jon
{% endcomment %}

## Shell คืออะไร? (What is the shell?)

ไอ้เครื่องคอมพิวเตอร์สมัยนี้มันมีหน้าตา Interfaces ให้เราเลือกใช้สั่งงานกันสารพัดรูปแบบเลยครับ ทั้งแบบ Graphical User Interfaces (GUI) สวยๆ, สั่งงานด้วยเสียง (Voice interfaces), ลุยโลกเสมือน (AR/VR), และน้องใหม่ไฟแรงอย่าง LLMs อินเตอร์เฟซพวกนี้มันเกิดมาดีฮะ และมันตอบโจทย์ Use-cases ทั่วไปตามที่เราต้องการได้กว่า 80% เลยนะ แต่เอาเข้าจริง... มันมักจะมีกำแพงบีบให้เราทำได้แค่ตาม "สิ่งที่เค้าออกแบบมาให้ทำเท่านั้น" — คุณจะไปเนียนกดปุ่มที่มันไม่มีอยู่ให้กดก็ไม่ได้ หรือจะไปพ่นสั่งเสียงในเครื่องหรือคำสั่งที่มันยังไม่ได้ลืมตาตื่นมาเรียนรู้โปรแกรมก็ไม่ได้เหมือนกัน ถ้าคุณอยากจะดึงพลังของ Tools ที่คอมพิวเตอร์ซ่อนไว้มาใช้แบบเต็มสตรีมและรีดประสิทธิภาพออกมาได้สุดตัวล่ะก็ เราก็คงต้องงัดเอาวิธีสุดคลาสสิก (old-school) กลับมาพึ่งพาอินเตอร์เฟซแบบตัวอักษรพิมพ์สั่งงานกันยาวๆ นั่นก็คือการใช้: The Shell ครับ

แทบทุก Platform ที่คุณได้จับหรือมีโอกาสผ่านหูผ่านตาน่าจะต้องให้ตัว shell แบบใดแบบหนึ่งมาด้วยเสมอล่ะ แถมหลายๆ OS ก็มี shells ให้คุณจิ้มเลือกได้ตามใจชอบเต็มไปหมด แม้ว่าพวกมันอาจจะมีหน้าตาหรือลูกผสมปลีกย่อยที่ต่างกันไปบ้าง ทว่าในแก่นแท้ก้นบึ้งของมันแล้วพวกมันก็ทำงานคล้ายๆ กันอยู่ดีครับ: ซึ่งก็คือมันอ้าแขนรับให้คุณสามารถสั่งรันโปรแกรมได้ ส่งข้อมูล (Input) เข้าไปให้มันประมวลผลได้ และรออ่านเช็คข้อมูล (Output) ที่บ้วนออกมาในรูปแบบที่ค่อนข้างเป็นระบบระเบียบ (semi-structured way) ได้ครับ

ก่อนที่เราจะมางัดเปิดจอพิมพ์เรียกตัว _prompt_ ของ shell (เพื่อสาดพิมพ์คำสั่ง) เราจำเป็นต้องมีสิ่งแรกก่อน นั่นคือสิ่งที่เรียกว่า _Terminal_ ซึ่งมันก็คือตัวหน้าต่างภาพที่คอยเอามาครอบโชว์เนื้อหาให้กับ shell ของเรานั่นเองฮะ เครื่องที่คุณใช้อยู่ก็น่าจะมีแอบแฝงติดเครื่องมาให้เป็นพื้นฐานอยู่แล้ว หรือถ้าไม่มีก็หาทางลงได้สบายๆ ง่ายมากครับ:

- **Linux:**
  กด `Ctrl + Alt + T` (ท่านี้รันและเวิร์กกับ Distributions ส่วนใหญ่เลยฮะ) หรือถนัดหน่อยก็คือลองเซิร์ชหาคำว่า "Terminal" ในช่อง applications menu เดี๋ยวมันก็เด้งมาเอง
- **Windows:**
  กดปุ่ม `Win + R`, พิมพ์ `cmd` ไม่ก็ `powershell` แล้วทุบปุ่ม Enter เบาๆ หรืออีกท่าก็เซิร์ช "Terminal" หรือ "Command Prompt" ตรงหน้าเมนู Start
- **macOS:**
  กระแทกปุ่ม `Cmd + Space` ดึงหน้าต่าง Spotlight ขึ้นมา, พิมพ์ "Terminal" ค้นหา แล้วคีย์ Enter รัวๆ หรือแวะไปแหวกหาที่ Applications → Utilities → Terminal ก็ยังได้ครับ

บนระบบ Linux และ macOS ถ้าคุณเปิด terminal ขึ้นมาตัวที่คุณมักจะเจอเลยก็มักจะเป็น Bourne Again SHell หรือที่เราเรียกกันติดปากสุดๆ ว่า "bash" นี่แหละ ตัวนี้เรียกได้ว่าเป็น shell คู่บุญที่คนใช้กันเกร่อและเยอะที่สุดตัวนึงเลยก็ว่าได้ แถมตัว syntax คำสั่งของมันก็ยังแชร์คอนเซปต์ซ้ำรอยคล้ายคลึงกับที่คุณจะเห็นใน shells ตัวอื่นๆ ด้วย ส่วนถ้าเป็นทางฝั่ง Windows คุณจะได้รับการโบกมือทักทายจากหน้า shell สายพันธุ์ "batch" ไม่ก็ "powershell" แทน (ขึ้นอยู่กับว่าคุณเลือกเปิดจิ้มรันค่ายไหนขึ้นมา) เจ้าพวกนี้ถือเป็นตัวของฝั่งเจาะจง Windows-specific โดยแท้ ซึ่งก็ไม่ใช่ตัวที่เราจะหยิบมาโฟกัสเทรนกันในคลาสนี้หรอกนะฮะ (ถึงแม้โดยหลักการมันจะมีกลไกเทียบเคียงที่ก็คล้ายๆ กับสิ่งที่เราจะสาธยายบอกสอนไปก็ตามที) คำแนะนำของเราคือให้งัดไปซบใช้ [Windows Subsystem for Linux (WSL)](https://docs.microsoft.com/en-us/windows/wsl/) หรือไม่ก็แอบรันบนตัว Linux virtual machine แทนไปซะจะจบงานเนียนๆ เข้าขากว่าเยอะ

และในท้องตลาดมันก็ยังมี shells ตัวอื่นๆ ให้เลือกเสพอีกเพียบฮะ ซึ่งหลายตัวมักมีฟีเจอร์แจ่มๆ ที่ถูกปรับแก้มาให้ล้ำและดูลื่นหน้ามี Ergonomic improvements ที่เหนือชั้นขิงใส่ bash แบบห่างชั้นเลยแหละ (เช่น fish และ zsh ที่ทรงฮิตๆ กันอยู่ช่วงนี้) แต่ถึงแม้มันจะป๊อปคอร์นกินใจแอร์ไทม์ชาวบ้านไปมากแค่ไหน (แอบบอกว่าอาจารย์ผู้สอนในคลาสนี้ทุกคนก็มีใช้กันนะ) มันก็ยังมีฐานมวลชนที่ไม่ได้แพร่หลายครอบคลุมระดับฝั่งของ bash อยู่ดีครับ แถมแนวคิดหลักๆ ส่วนมากก็ยังลอกและยึดโครงพื้นฐานอิงอยู่กับคอนเซ็ปต์เดียวกันเป๊ะๆ ด้วย เพราะงั้นรอบนี้เราก็เลยตัดสินใจจะขอพักยังไม่ขยี้ลงลึกไปโฟกัส shell พวกนั้นในการบรรยายบทนี้นะครับ

## ทำไมต้องใส่ใจมันด้วยล่ะ? (Why should you care about it?)

การควบคุมผ่าน Shell นี่ไม่ได้แปลว่ามันจะทำได้เร็วกว่าแค่ "การลากเมาส์เสิร์ชแล้วคลิก" เสมอไปหรอกฮะ (แม้ปกติตัวมันมักจะเป็นงั้นจริงๆ ก็เถอะ) แต่มันมาพร้อมกับขุมพลังและความยืดหยุ่น Expressive power ในระดับที่คุณไม่สามารถหามาซัปพอร์ตได้ง่ายๆ จากโปรแกรมที่พึ่งแต่หน้าต่าง GUI ทั่วไปเป็นตัวขับเคลื่อนแค่อย่างเดียวเลยล่ะ เดี๋ยวเราจะได้เรียนรู้กันครับว่า เจ้าเปลือก shell เนื่ยมันหยิบยื่นความสามารถวิเศษให้คุณพร้อมรับสิทธิ์ที่จะ "จับรวมร่าง(combine)" โปรแกรมหลายตัวเข้าด้วยกันและพลิกแพลงใช้กับทริคต่างๆ สร้างสรรค์งาน automate มาช่วยทุ่นแรงแบบครอบจักรวาลแก้ปัญหางานได้เกือบแทบทุกโจทย์

ยิ่งไปกว่านั้น การที่คุณโชว์สกิลใช้ shell ได้อย่างทะลุปรุโปร่ง ยังเปรียบเหมือนมีสกิลติดตัวไปลุยเบิกทางให้คุณฝ่าฟันลุยดงใช้ของจากโลกของ Open-source software (ที่มักจะสอดไส้ทิ้งคู่มือรันติดตั้งเป็นแบบสไตล์ Command-line ผ่าน shell ไว้ให้ออกบ่อย) หรือแม้แต่ในจังหวะที่คุณจะต้องพยายามสร้างตัวช่วยรัน Continuous Integration ใส่เข้าไปให้สำหรับโปรเจกต์งานเดฟของตัวคุณเอง (เรื่องหัวนี้เดี๋ยวเราอธิบายเจาะกันใน [Code Quality](/2026/th/code-quality/)), หรือในวันที่คุณต้องลงแรงหน้าดำคร่ำเครียดแงะโค้ดนั่งเชค Debug errors หาตัวการเวลาที่โปรแกรมคนอื่นดันเจ๊ง ไม่ก็ล้มลงรันไม่ได้ฮะ

## การท่องโลกใน shell (Navigating in the shell)

เมื่อคุณเปิด terminal ขึ้นมา คุณจะเจอกับแผงข้อความตั้งต้นที่เรียกว่า _prompt_ ซึ่งหน้าตาก็มักจะออกมาประมาณนี้ฮะ:

```console
missing:~$
```

ตัวอักษรพวกนี้คืออินเตอร์เฟซหลักที่ใช้สื่อสารกับ shell ครับ มันกำลังบอกเป็นนัยว่าคุณกำลังล็อกอินสิงสถิตอยู่บนเครื่องคอมพิวเตอร์ชื่อ `missing` และตำแหน่งโฟลเดอร์ปัจจุบัน ("current working directory") หรือถิ่นที่คุณกำลังเหยียบย่ำอยู่ก็คือโฟลเดอร์ `~` (เป็นตัวย่อของโฟลเดอร์ "home" นั่นเองฮะ) เครื่องหมายท้ายสุดตัวดอลลาร์ `$` คือรหัสลับแอบบอกว่าคุณไม่ได้สิทธิระดับแอดมินหรือ root user แต่อย่างใด (เดี๋ยวหัวข้อนี้กั๊กไว้ไปขยี้กันต่อทีหลังนะ) จากจุด prompt ตรงนี้เอง คุณสามารถป้อนพิมพ์ _command_ ลงไปได้เลย แล้วเดี๋ยว shell มันจะตีความจัดการต่อให้เองครับ ซึ่งท่าเบสิกที่สุดของการป้อน command ก็คือการสั่งรันโปรแกรมนั่นแหละ:

```console
missing:~$ date
Fri 10 Jan 2026 11:49:31 AM EST
missing:~$
```

จากตัวอย่างนี้ เราได้เรียกโปรแกรมที่ชื่อ `date` ขึ้นมาทำงาน ซึ่งหน้าที่ของมันก็ตรงตามชื่อเป๊ะ นั่นคือเสกโชว์วันและเวลาในปัจจุบันออกมาฮะ พอมันพ่นผลลัพธ์เสร็จ shell ก็จะดีดตัว prompt กลับมาตีหน้าซื่อรอให้เราป้อนคำสั่งต่อไปได้เลยทันที นอกเหนือจากนี้ เรายังสามารถแนบของแถมที่เรียกว่า _arguments_ พ่วงเข้าไปด้วยกับ command ได้ด้วยนะ:

```console
missing:~$ echo hello
hello
```

ในเคสนี้ เราวานให้ shell ไปปลุกโปรแกรม `echo` แล้วตะโกนฝาก argument คำว่า `hello` ติดไปด้วยฮะ ซึ่งไอ้โปรแกรม `echo` นี่มันมีหน้าที่ดื้อๆ เลยคือรับข้อความ (arguments) อะไรมาก็แค่ปริ้นต์โชว์สะท้อนกลับไปแค่นั้นเอง หลักการคือ shell มันจะใช้การ "เว้นวรรค" (whitespace) เป็นตัวหั่นคำสั่งออกเป็นชิ้นๆ จากนั้นมันหมายหัวคำแรกสุดให้เป็นตัวชูโรงบอกชื่อโปรแกรมที่ต้องเอาไปรัน ส่วนคำก้อนอื่นๆ ที่ต่อท้ายยาวไปนั่นแหละ มันจะเหมาโหลจับรวบรวมเป็น arguments ถวายใส่พานส่งโปรแกรมให้เอาไปใช้ต่อครับ ในกรณีที่คุณดันอยากจะโยน argument เดี่ยวๆ ที่ดันทะลึ่งมีข้อความเว้นวรรคผสมอยู่ข้างใน (อย่างเช่นชื่อโฟลเดอร์ "My Photos") คุณจะเจอไฟท์บังคับให้ต้องเอา quote มาคลุม arguments นั้นครับ ไม่ว่าจะเป็น single quote `'` หรือ double quote `"` ก็ได้ (เช่น `"My Photos"`) หรืออีกท่าก็สามารถเสกอักขระพิเศษอย่าง `\` ไปบังหน้าตัวสเปเซสได้เหมือนกันครับ (`My\ Photos`)

ตัวคำสั่งที่เรียกได้ว่าทรงอิทธิพลที่สุดสำหรับมือใหม่หัดขับน่าจะเป็น `man` นะ ย่อมาจากคำว่า "manual" นั่นแหละ โปรแกรม `man` มันจะยอมให้คุณงัดเอาคู่มือหรือข้อมูลเบื้องลึกเบื้องหลังของทุกๆ command ในระบบออกมาดูได้ ยกตัวอย่างเช่น ถ้าคุณเกิดสงสัยจัดแล้วกดสับไก `man date` มันก็จะกางตําราว่าน้อง `date` คือใคร ทำงานยังไง แล้วมีลีลาแงะ arguments ตัวไหนโยนให้มันแปลงกายงัดท่าแปลกๆ ได้บ้าง คุณยังสามารถหาข้อความช่วยเหลือแบบสรุปย่อได้จากการโยน `--help` ไปเป็น argument ท้ายคำสั่งของโปรแกรมส่วนใหญ่นะครับ

> แอบป้ายยาว่าคุณควรไปตำ [`tldr`](https://tldr.sh/) มาติดเครื่องควบคู่กับการใช้ `man` ไปด้วยเลยฮะ เพราะมันมักจะป้อนสรุปกางให้เห็นถึงตัวอย่าง usage ที่ใช้กันบ่อยๆ ฮิตๆ ได้ถูกจริตและง่ายกว่าใน terminal อีกอย่างนึงคือ เดี๋ยวนี้บรรดา LLMs มักจะเป็นเซียนอธิบายลีลาการทำงานของพวกคำสั่งต่างๆ ได้เทพและเคลียร์สุดๆ ช่วยไกด์ได้แม่นมากเลยฮะว่าต้องสั่งท่าไหนจะได้ผลลัพธ์ตามที่คุณต้องการเป๊ะๆ

ถ้าผ่านด่าน `man` มาแล้ว คำสั่งสุดยอดคิวทองระดับถัดมาที่คุณไม่รู้จักไม่ได้ก็คือ `cd` หรือชื่อเต็มๆ ว่า "change directory" นั่นเองฮะ จริงๆ ตัวนี้มันคือฟีเจอร์ระดับ built-in ที่ฝังมากับ shell เลย ไม่ได้แยกตัวออกมาเป็นโปรแกรมสแตนด์อโลน (i.e. สมมติถ้ารัน `which cd` จอคุณก็จะบ้วนคำว่า "no cd found") เวลาใช้งานคุณก็แค่โยนก้อน path ดินแดนที่คุณอยากผจญภัยไปส่งให้มัน แล้ว path ตรงนั้นก็จะกลายร่างมาเป็น current working directory (ฐานบัญชาการปัจจุบัน) ของคุณทันทีฮะ คุณสามารถซุ่มแอบลอบมองเช็คสถานะการเข้าพักของ directory ได้จากตัวอักษรที่ขึ้นบน shell prompt เลย:

```console
missing:~$ cd /bin
missing:/bin$ cd /
missing:/$ cd ~
missing:~$
```

> อย่าเพิ่งลืมว่า shell มันมีฟีเจอร์ช่วยเติมคำ (auto-completion) มาให้แต่เกิดฮะ เพราะงั้นส่วนใหญ่คุณกดรัวพิมพ์เปิดไปแค่นิดเดียวแล้วกดปุ่ม `<TAB>` เพื่อให้มันป้อนจบ path ยาวๆ ได้แบบไม่ต้องเมื่อยนิ้วเลยนะ!

โปรแกรมคำสั่งส่วนมาก มักจะสุมหัวใช้ฐาน `current working directory` ของคุณนั่นแหละเป็นพื้นที่ทดสอบเวลาที่คุณไม่ได้โยนตัวแปรเฉพาะเจาะจงลงไป หากวันไหนเกิดหลงเวิ้งขุ่นมัวจนไม่แน่ใจว่าตัวคุณเองไปสิงอยู่หลุมไหน คุณสามารถรันสืบค้นได้ด้วย `pwd` หรือแงะข้อมูลสิ่งแวดล้อมจากตัวแปร `$PWD` เอาด้วย (รันป้อนด้วย `echo $PWD`) ซึ่งทั้งคู่ก็เป็นคู่หูที่ช่วยเสิร์ชหาสถานะ current working directory โชว์กลับมาให้คุณครับ.

ความฉลาดของเจ้า current working directory นี้ยังก้าวไปอีกขั้นเพราะมันช่วยเปิดช่องทางให้เราสามารถประยุกต์ใช้แบบ _relative_ paths (เส้นทางสัมพัทธ์) ได้ด้วยฮะ เส้นทาง path ทั้งหมดที่เราเจอเลื่อนขึ้นดูด้านบนมานั้นเป็นพวกสายตระกูล _absolute_ paths ล้วนๆ เลย — หมายความว่ามันเริ่มต้นเดินสับขาด้วย `/` โชว์ตารางโครงสร้าง directories ตั้งแต่ระดับบนสุดเสร็จสรรพ (ตัว `/`) ไล่ลากจูงมาตามลำดับ แต่บอกเลยว่าชีวิตในโลกทำงานจริง คุณจะใช้ตัว relative paths กันจนเบื่อแน่นอน; ได้ชื่อว่าสัมพัทธ์ก็เพราะมันอ้างอิงทางเดินก้าวแรกเริ่มจากตัว current working directory ของคุณนั่นแหละ โดยในการอธิบายตำแหน่งทรง relative path (หรือเอาง่ายๆ คือไอ้เส้นทางไหนก็ตามที่ก้าวเท้าท่อนเปิด _ไม่ได้_ เริ่มด้วย `/`) ท่อนเส้นทางอักษรปฐมบทจะมุดขุดคุ้ยค้นหาจาก current working directory เสมอ แล้วไอ้ส่วนท่อนหางยาวหลังจากนั้นก็ค่อยหักเลี้ยวเสาะหาดำดิ่งเข้าไปข้างในเป็นสเต็ปตามปกติ ตัวอย่างฮะ:

```console
missing:~$ cd /
missing:/$ cd bin
missing:/bin$
```

มีแก๊งป่วนพิเศษ components ห่อหมกในทุก directory ด้วยกันอยู่ 2 ตัวถ้วนครับ: นั่นก็คือ `.` กับ `..` ความหมายคืออะไร? `.` สื่อตัวมันเองเลยว่า "นี่แหละห้องปัจจุบัน" (this directory) แล้วก็ `..` จะให้ความหมายทรงถอยหลังว่า "เลื่อนออกไปยังห้องพ่อคุมกำเนิดของมัน 1 สเตป" (the parent directory) อย่างเช่น:

```console
missing:~$ cd /
missing:/$ cd bin/../bin/../bin/././../bin/..
missing:/$
```

ส่วนมากแล้ว... คุณสามารถที่จะรวบกอดผสมจิ้มใช้ absolute และ relative paths รัวสลับกันไปมาได้แบบอิสระใน command argument แทบทุกที่เลยครับ แค่ต้องตั้งหมั่นมีสติเอาไว้ว่าตัวฐาน current working directory ของคุณในตอนที่กดเรียก relative paths น่ะ มันตั้งรกรากอยู่ตรงไหนก็พอ!

> ขอแชร์ทริคนอกเรื่องนิดนึงฮะ... แวะไปสรรหาดึงและติดตั้งใช้งาน [`zoxide`](https://github.com/ajeetdsouza/zoxide) ดูสิ มันโกงช่วยสปีดอัประดับการรัวสับเปลี่ยนห้องของคุณเร็วเป็นอีกขั้นระดับ --- ด้วยการพิมพ์ `z` เพียวๆ พ่อหนุ่มหัวใสตัวนี้มันจะแอบจดจำประวัติ paths ที่คุณแวะค้างบ่อยเข้ากระดูกดำ แล้วให้สิทธิบัตรซัดเปิดประตูห้องลัดปรู๊ดปร๊าดแบบไม่ต้องเมื่อยนิ้วกดแช่นานครับ

## มีของเล่นอะไรให้รันบ้างใน shell? (What is available in the shell?)

คำถามคือ แล้วเปลือก shell มันตรัสรู้ได้ยังไงล่ะว่าต้องงมไปหาโปรแกรมอย่าง `date` หรือ `echo` จากป่าไหน?
อธิบายง่ายๆ ฮะ เวลาที่ shell โดนสั่งให้รันคำสั่งอะไรสักอย่าง มันจะหันไปตบไหล่ปรึกษากับ _ตัวแปรสภาพแวดล้อมระบบ (environment variable)_ ตัวนึงที่ชื่อว่า `$PATH` ซึ่งไอ้ตัวแปรเนี้ย มันทำหน้าที่เป็นเหมือนลายแทงลิสต์ว่า shell ควรจะหน้าด้านไปควานหาโฟลเดอร์ไหนบ้างเพื่อตามล่าหาโปรแกรมเวลาที่ได้รับสาส์นคำสั่งมา:

```console
missing:~$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
missing:~$ which echo
/bin/echo
missing:~$ /bin/echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
```

ตอนที่เราทุบ enter สั่งรันคำสั่ง `echo` ไปนั้น ตัว shell มันจะรู้ตัวว่าต้องปลุกโปรแกรม `echo` ขึ้นมานะเว้ย จากนั้นมันก็จะรีบวิ่งไล่สแกนกวาดหาทะลวงผ่านแผงรหัสโฟลเดอร์ที่โดนคั่นด้วย `:` ในก้อนตัวแปร `$PATH` เพื่องมหาไฟล์ที่ชื่อเป๊ะตามนั้นให้เจอฮะ พอเจอเป้าหมายปุ๊บ มันก็จะจับรันทำงานเลยทันที (ภายใต้กฎเหล็กคือ ไอไฟล์นั้นมันต้องมีสิทธิ์เป็นไฟล์ที่ทะลวง _executable_ สั่งรันได้นะ; เดี๋ยวหัวข้อนี้ไว้ขยี้ทีหลัง) คุณสามารถสืบหาไส้ในแอบดูได้เลยนะว่า ไอคำสั่งโปรแกรมที่เราเรียกใช้อยู่นี่ ตกลงแล้ว shell มันแอบไปดึงไฟล์หน้าตาแบบไหนจากซอกหลืบไหนมารันให้ โดยใช้โปรแกรม `which` มาช่วยหาให้ครับ หรืออีกเวหา ถ้าเราขี้เกียจไปพึ่งพิงยืมจมูก `$PATH` หายใจ เราก็ทำแค่รันโดยยัด _path เต็มๆ_ หรือโยนเส้นทางแบบระบุตำแหน่งไฟล์เป๊ะๆ เข้าไปรันให้มันเลยก็ได้เหมือนกัน

เกร็ดเล็กๆ นี่แหละครับที่มันช่วยเป็นคําใบ้ชี้ช่องให้คุณนึกออกแล้วใช่มั้ยว่า งั้นเราสามารถงัดดู _ทุกๆ Programs_ ที่ระบบอนุญาตให้รันได้ใน shell ได้ทั้งหมดเลยปะวะ? คำตอบคือ "ได้ดิวะ"! เราก็แค่หว่านไถคำสั่งสั่งลิสต์ไส้ในของทุกๆ โฟลเดอร์ที่ซ่อนสิงอยู่ในตัวแปร `$PATH` ออกมาดูให้หมดเลยฮะ ซึ่งท่าง่ายๆ เราก็แค่โยนโฟลเดอร์เหล่านั้นไปให้โปรแกรม `ls` (ที่แปลว่า list files) งัดของออกมากางนั่นแหละ:

```console
missing:~$ ls /bin
```

> ของมันต้องขิง... ขอป้ายยาอวยให้ลองไปโหลด [`eza`](https://eza.rocks/) มาใช้แทนตัว `ls` รุ่นพระเจ้าเหาสักหน่อยฮะ มันมีตัวโชว์ที่โคตรจะ human-friendly สวยเนียนตากับคนอ่านกว่าเยอะเลยแหละ

ไอ้คำสั่ง `ls /bin` นี่นะฮะ ด้วยคอมร้อยทั้งร้อยพอกดรันแล้ว... รับรองเลยว่าคุณจะได้จอที่ปริ้นต์ชื่อโปรแกรมบานสะพรั่งออกมา _บานตะไท_ ยาวเป็นหางว่าวแน่ๆ แต่เราจะร่อนเร่ขอโฟกัสหยิบเฉพาะตัวเด็ดๆ เนื้อๆ ที่เค้านิยมใช้กันมากางให้ดูแล้วกันครับ ซอฟต์ๆ ก่อนเลย:

- `cat file` - จับเนื้อหาไส้ในของไฟล์ปริ้นต์สาดขึ้นจอโต้งๆ เลย
- `sort file` - รันจับทุกบรรทัดของไฟล์มาเข้าแถวเรียงลำดับให้เนียนกริ๊บทรง sorted
- `uniq file` - เป็นมือสังหารคอยกรองตัดบรรทัดที่ซ้อนร่างซ้ำๆ (duplicates) ที่อยู่ติดๆ กัน ออกจากไฟล์ให้เกลี้ยง
- `head file` และ `tail file` - โปรแกรมหยิบจับแบบระบุหัวท้าย ซึ่งก็จะปริ้นต์หยิบแค่ท่อนหัวไม่กี่บรรทัดแรก หรือเตะเอาแค่ท่อนหางบรรทัดท้ายๆ ของไฟล์ออกมาโชว์ฮะ

> ป้ายยาอีกดอก: ลองสอย [`bat`](https://github.com/sharkdp/bat) มาสถิตใช้แทนคอมมานด์ `cat` เก่าๆ ของคุณดูฮะ เเล้วคุณจะติดใจกับตัว syntax highlighting ไฮไลท์สีแยกตัวอักษรกับสไลด์ตาสมองไหลลื่นๆ ของมัน

นอกจากนี้ เรายังมีทีเด็ดอย่าง `grep pattern file` ที่จะคอยทำหน้าที่กางไฟล์งมล่าหาบรรทัดที่มีข้อความตรงเป๊ะเข้ากับคำค้น `pattern` ครับ โปรแกรมตัวนี้มันของแรงที่คู่ควรเจียดเวลามาลูบคลำมันสักนิด เพราะคุณประโยชน์มัน _ทะลุหลอด_ พ่วงฟีเจอร์จุกๆ เยอะแยะเหนือจินตนาการมากฮะ ตัว `pattern` จริงๆ มันก้าวล่วงเอา _regular expression_ (นิพจน์ปรกติ) ที่ครอบจักรวาลแปรฟอร์มไปประติมากรรมเสกเป็นรูปแบบการค้นหาที่สุดแสนจะซับซ้อนก็ได้ --- เดี๋ยวเรามีจ่อเลคเชอร์ [เจาะลึกเรื่องนี้แบบเต็มๆ](/2026/th/code-quality/#regular-expressions) กันในบทของ Code quality นะครับ คุณสามารถประเคนชื่อโฟลเดอร์ directory ยัดแทนการระบุไฟล์เดี่ยวๆ ให้มันได้เหมือนกัน (หรือขี้เกียจใส่ก็เคาะเป็นคอมมานด์ `.` ไป) แล้วตอกย้ำด้วย parameter `-r` โยนพ่วงให้มันลงแรงตามปูพรมค้นทุกซอกซอยไฟล์ให้ลึกเข้าไปยันก้านมะยมของไดเรกทอรีงุ้งงิ้งๆ ได้อีกแน่ะ

> อยากซิ่งต้องลองของนะ... เราเชียร์ให้ติดตั้งและปล้ำรัน [`ripgrep`](https://github.com/BurntSushi/ripgrep) ใช้แทน `grep` ยุคไดโนเสาร์ฮะ ตัวนี้ทั้งรีดความเร็วปรี๊ดปร๊าดเป็นจรวด แถมยังส่งรีพอร์ตโชว์สวยเนียนตากับคนมากกว่า (ถึงแม้อาจจะพกพายกไปรันแพลตฟอร์มอื่นไม่ง่ายนักก็เหอะ) แถมความดีงามคือ `ripgrep` มันก็ตั้งลิมิตค่าเริ่มต้นเป็น default สับขาหลอกให้งมขุดคุ้ยหาโฟลเดอร์ปัจจุบันแบบ recursively search ให้อัตโนมัติด้วยนะเว้ย!

ถัดมาฮะ... ยังมีกองกำลังเครื่องมือเด็ดดวงที่มี interface อาจจะดูซับซ้อนปวดขมองขึ้นมาอีกนิด ตัวเป้งๆ เลยก็เช่นพี่ `sed` ซึ่งมันคือปรมาจารย์เรื่อง programmatic file editor (นักโมดิฟายด์แก้ไขไฟล์ด้วยมาดโปรแกรมมิ่ง) มันมีจักรวาลภาษาโปรแกรมของตัวมันเองที่เอาไว้ไล่แงะจับสับเปลี่ยนไฟล์โดยอัตโนมัติเลยฮะ แต่ท่าโพสเบสิกที่เค้านิยมงัดมาตบทรัพย์ใช้บ่อยที่สุดก็หนีไม่พ้นการใช้สับข้อความนี่แหละ:

```console
missing:~$ sed -i 's/pattern/replacement/g' file
```

ไอ้คำสั่งงูๆ ปลาๆ ด้านตะกี้นี้แหละ ความหมายมันคือ: สั่งประหารไล่แทนที่เนื้อหา `pattern` ทุกติ่งที่โผล่มาให้เห็นด้วยตัวอักษรใหม่ `replacement` ภายใน `file` ครับ ตัว `-i` คือรหัสลับแง้มบอกว่าเราอยากให้กระบวนการเชือดเปลี่ยนร่างนี้ เกิดขึ้นและทับถมลงตัวไฟล์แบบดื้อๆ ถาวรไปเลยนะ inline edit อะ (แทนที่จะแค่ปริ้นต์บ้วนผลลัพธ์ผ่านหน้าจอแล้วปล่อยไฟล์เป้าหมายรอดตัวไม่บุบสลายไปเฉยๆ) ส่วนไอ้เครื่องหมาย `s/` อันนี้เปรียบดั่งภาษาใบ้ของก๊วนโปรแกรม sed ไว้สะบัดบอกชี้ตรงๆ เลยว่า "เฮ้ย ข้าต้องการทำ substitution (แทนที่) นะเฟ้ย" ตัวเส้นแบ็กสแลช `/` มีไว้ทำคอกขวางกั้นระหว่างคำที่ต้องการหากับคำที่จะเอามาเสียบแทน และไอ้ตรงชิ้นหางปลา `/g` ที่แอบติ่งอยู่ด้วยนั่น เป็นตัวกำกับว่าให้ช่วยวิ่งกวาดแทนที่มันซะ _ทั้งหมด_ ของทุกๆ บรรทัดเลยนะ ไม่ใช่เอาแค่คำแรกสุดที่เจอแล้วก็เลิกทำ เหมือนกันกับของ `grep` เป๊ะเลยฮะ ตัว `pattern` ที่ยัดเข้าไปนี้ คุณสามารถงัดท่า _regular expression_ ใส่ลงไปได้ ซึ่งมันจะเสกพลังอำนาจการระบุที่โคตรจะอภินิหารให้คุณ แถมฟีเจอร์ระดับเทพของ Regular expression มันก็ดันยินยอมให้ ไอ้ตัวคำ `replacement` สามารถเรียกดูดจั๊มป์เชื่อมข้อมูลอ้างอิงย้อนกลับดึงมาจากกลุ่มแพทเทิร์นจับที่กางตาข่ายครอบไว้ได้อีกด้วย; เดี๋ยวเรามีของดีสาธิตโชว์ให้แงะดูให้เห็นภาพในไม่กี่อึดใจนี้ฮะ.

ของขลังลำดับถัดไป เราขอมอบมงให้พี่ `find`, ทวยเทพแห่งการตามล่าหาไฟล์ (แถมมุดซอกซอนเข้าแบบ recursively) ที่มีเงื่อนไขเป๊ะปังตามที่คุณตั้งกฎครอบเอาไว้ ตัวอย่างเช่นแบบนี้ฮะ:

```console
missing:~$ find ~/Downloads -type f -name "*.zip" -mtime +30
```

มันจะวิ่งหน้าตั้งตามหาของในโฟลเดอร์ดาวน์โหลดว่ามีไฟล์ ZIP ตัวไหนบ้างที่เก่าเหม็นบูดนอนอืดมานานเกินกว่า 30 วันแล้ว.

```console
missing:~$ find ~ -type f -size +100M -exec ls -lh {} \;
```

หาไฟล์ตัวอ้วนๆ ที่มีขนาดซดพื้นที่อิ่มๆ ใหญ่กว่า 100M ขึ้นไปใน home directory แล้วลิสต์กางมันออกมาโชว์ฮะ โปรดสังเกตนะว่าการส่งพารามิเตอร์ `-exec` มันจะไปปลุกผีลากคำสั่ง _command_ สังหารตัวนึงขึ้นมา แล้วปิดท้ายคอมโบด้วยตัว stand-alone วายร้าย `;` (ซึ่งตามกฎแล้วเราจำเป็นต้องกดสวม escape `\` ให้มันคล้ายๆ เว้นวรรคนั่นแหละ) โดยที่ไอ้ตัวกรอบช่องว่าง `{}` จะถูก `find` ดึงผลลัพธ์ path ทั้งหมดที่งมเจอมาทยอยจับยัดห่าสาดใส่รัวๆ สลับกันไปแบบอัตโนมัติฮะ.

```console
missing:~$ find . -name "*.py" -exec grep -l "TODO" {} \;
```

ค้นหาครอบคุมไล่ขุดคุ้ยไฟล์นามสกุล `.py` ทั้งหมดที่แอบมีความลับข้อความซุกซ่อนคำว่า TODO สิงอยู่ข้างในฮะ.

ความมึนงงในการพยายามนั่งพิมพ์จดจำ syntax ของ `find` ในแวบแรกอาจจะให้ฟีลเหมือนเดินดงหญ้ารกชันชวนท้ออยู่บ้าง แต่ก็แอบหวังนะฮะว่า ตัวอย่างพวกนี้มันจะพอกระตุกต่อมให้เห็นเลยว่า ไอ้หมอนี่แม่งทรงพลังน่าหยิบมาใช้แค่ไหน!

> ขอแวะป้ายยาอีกรอบ: ลองแวะไปกราบไหว้โหลด [`fd`](https://github.com/sharkdp/fd) เข้ามาใช้งานแทนที่ `find` โบราณๆ ดูครับ ได้ใจมวลชนเรื่องความเป็นมนุษย์ (human-friendly) สบายตาใช้ง่ายมาก (ถึงแม้ข้อเสียจะแลกมาเรื่องที่ไปหิ้วรันเครื่องชาวบ้านอาจจะไม่ง่ายนัก Portable น้อยกว่าก็ตามทีนะ!)

ของดีลำดับสุดทัายที่เรียงคิวรอการใช้งานคือ `awk` ซึ่งตัวนี้ก็อีหรอบเดียวกับ `sed` ฮะ คือมีภาษา programming ของตัวมันเองอภิสิทธิ์ชนเลย ในขณะที่พี่ `sed` เกิดมาเพื่อจับไฟล์มาหั่นดัดแปลงแก้ไข, น้อง `awk` แกเกิดมาพร้อมคติทุบไฟล์มาประมวลผลแตกกระจุย (parsing them) ฮะ ท่ายอดฮิตสแตนดาร์ดที่งัดพี่ `awk` มาตีกินตีกินฟาร์มบ่อยสุด คงหนีไม่พ้นการจับเอาไปกระซวกไฟล์เก็บฐานข้อมูลแบบตารางดاتاที่มีกฎระเบียบ Syntax นิ่งๆ (อย่างพวกไฟล์ CSV) ซึ่งหัวใจคือคุณแค่กระหายอยากจะดึงจกเอาบางพาร์ต บางส่วนย่อยของเนื้อหา record (หรือแค่ใน 1 บรรทัด) ออกมาใช้แค่นั้นฮะ อย่างเช่น:

```console
missing:~$ awk '{print $2}' file
```

มันจะดึงกระฉากเอาลิสต์ข้อมูล คอลัมน์ที่ 2 สะบัดรอยต่อด้วยจุดเว้นวรรค (whitespace-separated column) ของทุกๆ บรรทัดใน `file` ออกมาปริ้นต์ฮะ ถ้าคุณแอบซุกตัวเปลี่ยน `-F,` เข้าไปร่วมแจม มันก็ฉลาดพอที่จะปริ้นต์แค่คอลัมน์ลำดับที่สองโดยอิงรอยตัดจากตัวจุลภาคคอมม่าแทนทุกบรรทัดเลย `awk` มันวาดลวดลายดิ้นได้ซับซ้อนกว่านี้อีกเยอะฮะ --- เป็นทั้งตระแกรงร่อนกรองแถว filtering rows, ประมวลคำนวณรวบยอด aggregates ให้, แล้วก็บลาๆ อีกเป็นกอง --- ลองแวะไปด้อมๆ มองๆ ในโจทย์แบบฝึกหัด (exercises) กันได้ กะเอาพอให้เป็นแค่น้ำจิ้มรู้รสชาติพอฮะ.

ทีนี้พอลองเอาอุปกรณ์ของขลังทั้งหมดมามัดรวมร่างจับโปเตโต้ฟิวชันกันดู เราก็สามารถเสกให้เกิดเวทมนตร์อลังการแบบนี้ได้เลยฮะ:

```console
missing:~$ ssh myserver 'journalctl -u sshd -b-1 | grep "Disconnected from"' \
  | sed -E 's/.*Disconnected from .* user (.*) [^ ]+ port.*/\1/' \
  | sort | uniq -c \
  | sort -nk1,1 | tail -n10 \
  | awk '{print $2}' | paste -sd,
postgres,mysql,oracle,dell,ubuntu,inspur,test,admin,user,root
```

ไอ้ก้อนคำสั่งนี้มันเพิ่งจะทำโชว์เหนือ วิ่งไปคว้าท่อดึงข้อมูลบันทึกประวัติการใช้รัน SSH logs จากเครื่องเซิร์ฟเวอร์ระยะไกล (เรื่องไอ้ตัว `ssh` นี่เดี๋ยวเราขอเก็บกั๊กไว้ไปบ่นอธิบายต่อแบบเต็มที่ในพาร์ทเลคเชอร์หน้านะ) จากนั้นก็วิ่งคลำหาบรรทัดที่มีสาส์นคำว่า disconnect, ถกประหวัดกระซวกดึงเอาแค่ชื่อ username ของยูสเซอร์สวะสวะจากแต่ละข้อความออกมารวม, ยำผลลัพธ์จัดหนัก แล้วก็ตบท้ายด้วยการกางพ่นโพสต์บอกลำดับท็อป 10 ยูสเซอร์ฮิตติดชาร์ตออกมาแบบแผ่หลาแถมมีคอมม่าคั่นให้เสร็จสรรพ ทัายที่สุด ทั้งหมดนี้เสร็จสิ้นภายในลมหายใจสับไกคอมมานด์เดียวตูม! สำหรับการชำแหละไล่ผ่าทีละท่อนว่าไอ้ตัวไหนมันแอบทำอะไรบ้างนั้น... ขออนุญาตโยนบาปทิ้งไว้ให้เป็นเครื่องแบบฝึกหัดท้าทายชาวบ้านแล้วกันฮะ.

## ภาษาของ shell (The shell language - bash)

ตัวอย่างของรอบที่แล้วได้หิ้วเอาคอนเซ็ปต์ของเล่นใหม่อย่างนึงมาเปิดตัวด้วย นั่นก็คือ: ท่อสวม pipelines (`|`) ฮะ ตัวขีดกลางเนี่ยมันเกิดมาเพื่อให้คุณจับมัดร้อยเอาท่อบ้วนของออก (output) จากโปรแกรมตัวแรก ไปเสียบต่อเข้าช่องสูบของเข้า (input) ของโปรแกรมอีกตัวนึงเป็นทอดๆ ได้ หลักการนี้มันทำงานฉลุยก็เพราะว่า บรรดา programs คู่บุญของหน้าต่างคอมมานด์ไลน์ส่วนใหญ่มักจะดีไซน์มาให้ยินยอมรับก้อนเนื้อข้อมูลผ่าน "standard input" (ซึ่งก็คือช่องลมปกติจากที่คุณกระแทกคีย์บอร์ดพิมพ์ลงเป๊ะๆ นั่นแหละ) ในจังหวะที่มันโดนปลุกขึ้นมาแล้วไม่มีการโยน `file` argument จุกจิกอะไรมาให้มันฮะ พอเราตอกเครื่องหมาย `|` ปุ๊บ มันก็จะไปสอยเอาสายท่อน้ำทิ้ง "standard output" (ที่ตามปกติจะพุ่งปริ้นต์มาบนเทอร์มินัลเรานั่นแหละ) ของโปรแกรมก้อนหน้า `|` มาปั้นน้ำเป็นเส้น แล้วเสียบดัดแปลงให้กลายเป็นเส้นทาง standard input ไหลจ๊อกๆ ป้อนอุดปากให้กับโปรแกรมตัวหลัง `|` แทน ด้วยพลังเวทมนตร์นี้แหละ มันเปิดโอกาสให้คุณ _รวมร่าง_ (compose) หลากหลายโปรแกรมใน shell ได้อิสระสุดๆ และนี่ล่ะคือไม้ตายเด็ดที่ทำให้ environment แบบ shell กลายเป็นดินแดนมหัศจรรย์ที่ทรงประสิทธิภาพในการลุยงานมากๆ ฮะ!

เอาเข้าจริง shell แทบทุกตัวบนโลกมักจะฝังภาษา programming ภาษาหนึ่งแบบฟูลออปชัน (อย่างเช่น bash) ยัดไส้เอาไว้ข้างในด้วยนะ รัศมีแทบจะลูกพี่ลูกน้องกับพวก Python หรือ Ruby เลย มันสร้าง variables ได้, มี conditionals เช็คเงื่อนไข, วน loops, ควบยันสร้าง functions ก็ยังได้ เวลาที่คุณอัดตัวอักษรสั่ง commands ลงเปลือก shell เนี่ย จริงๆ แล้วคุณกำลังนั่งขีดเขียนร่างโค้ดเล็กๆ ให้ตัว shell มันไปแปลนั่งงมรันผลอยู่เบื้องหลังแหละฮะ ในวันนี้เราอาจจะไม่ได้พาทัวร์ทฤษฎี bash หมดเปลือกยับๆ นะฮะ แต่มีน้ำจิ้มของดีบางส่วนแหละที่คุณน่าจะหยิบไปตีบวกพลิกแพลงใช้จนชินได้เลย:

ตัวแรก, กฎการ redirects (เบี่ยงเส้นทางมวลสาร): `>file` จะเป็นท่าปล้นชิงตะกรันผลลัพธ์พวก standard output ของหน้าต่างโปรแกรม แทนที่จะบ้วนขึ้นประจานความโง่บนเทอร์มินัลของคุณ มันจะโดนดูดจับไปยัดไส้เขียนเซฟลงไปใน `file` แทน การกระทำแบบนี้มันช่วยชีวิตให้เรากลับมางัดไฟล์หาสืบวิเคราะห์ผลลัพธ์ทีหลังได้สะดวกโคตรฮะ ส่วนท่า `>>file` ก็แนวๆ เดียวกัน แค่มันไม่ได้บ้าเลือดทำลายล้างเขียนทับ (overwrite) หรอกนะ แต่มันจะซ้อนสับ append พอกพูนต่อท้าย `file` เรื่อยๆ นอกจากนี้มันยังมี `<file` ซึ่งจะใช้มนต์เกลี้ยกล่อมบังคับให้ shell ไปตักตวงสูบทรัพย์อ่านของจากก้นบึ้งใน `file` แล้วป่าวประกาศป้อนยัดให้กับโปรแกรมเป็นเสบียง standard input (แทนการนั่งเมื่อยพิมพ์กรอกข้อมูลด้วยมือนั่นเองฮะ)

> นี่แหละฤกษ์งามยามดีที่ขออนุญาตหยิบโปรแกรม `tee` มาอวยหน่อยละกัน ตัว `tee` มันก็คือตัวถ่ายผล (ปริ้นต์) standard input คายออกมาเป็น standard output นี่แหละ (อารมณ์คล้ายท่าของแฝดพี่ `cat` เป๊ะ!) แต่ความเจ๋งคือมันจะ _ก๊อป_ บ้วนสาดสำเนาอัดยัดลงไฟล์ให้ด้วยฮะ เพราะงั้นสมมติคุณรันอ้อมๆ `verbose cmd | tee verbose.log | grep CRITICAL` มันก็จะอ้วกซากล็อก verbose ดิบๆ ทั้งหมดแพ็กทิ้งไว้ในไฟล์เนียนๆ ในขณะที่หน้าต่าง terminal ของคุณก็ตีนิ่งโชว์สะอาดตา (มีโผล่แต่เฉพาะคำ CRITICAL!)

ถัดมา, การเช็คเงื่อนไข (conditionals): `if command1; then command2; command3; fi` มันก็จะทำการรัน `command1` ดูก่อนฮะ ถ้าสรุปมันไม่พ่น error ไปซะก่อน มันก็จะไปซิ่งไล่กดรัน `command2` แล้วก็ค่อยสะบัดไปดึง `command3` ออกมารันต่อฮะ แน่นอนว่าถ้าคุณอินดี้ ก็สามารถแวะพ่วงท่อน `else` ให้มันเป็นสาขาทางเลือกยามฉุกเฉินต่อได้ด้วย คำสั่งหน้าเดิมประจำการที่เค้านิยมดึงกระชากมาจับวางใส่ให้เป็น `command1` มากที่สุดก็คือโปรแกรมอย่าง `test` นั่ยแหละ (ส่วนโค้ดก็นิยมเขียนย่อเป็นอักษรเดี่ยวๆ เปิดด้วยก้ามปู `[` แค่นี้เลย), โปรแกรมตัวนี้มันเสกเปิดช่องให้คุณตั้งป้อมประเมินคำถามเชิงเงื่อนไขต่างๆ นานา เช่น "ไฟล์นี้มันมีมั้ยวะ" (`test -f file` / `[ -f file ]`) หรือ "เฮ้ย สอง string นี้มันต่อกันเป๊ะมั้ย" (`[ "$var" = "string" ]`) ในจักรวาล bash ยังมีอีกท่านึงนั่นคือ `[[ ]]` ด้วยนะ อันนี้กระซิบว่าเป็นตัว built-in อัปเกรดเวอร์ชันของ `test` ที่พกเอาลีลาการ quote ข้อมูลมาได้ปลอดภัยละมุนละม่อมและแผลงฤทธิ์ป่วนขัดกวนใจน้อยกว่าฮะ

จักรวาล bash ยังพกแก๊งลูปปั่นยอด 2 ทรงมาให้ด้วยนะ ได้แก่ `while` กับ `for` ฮะ ท่าแรก `while command1; do command2; command3; done` ก็ทำงานถอดแบบเดียวกับพวก `if` เลย เพียงแต่พอกดรันจนจบ done มันจะพลิกตัวเวียนจ่อหน้ากดรันคำสั่งทั้งหมดวนไปเรื่อยๆ ทบไปไม่หยุด (over and over) ตราบใดที่อีตัว `command1` ไม่ทะนุถนอมสร้าง error โผล่ออกมาขัดตาทัพฮะ ส่วน `for varname in a b c d; do command; done` อันนี้มันจะลุย execute `command` อัดไปเน้นๆ 4 ยกด้วยกัน ซึ่งในแต่ละรอบมันจะผลัดโอนตัวแปรตัวเอก `$varname` สไลด์ชิ่งเวียนค่าเป็นหนึ่งในช้อยส์ `a`, `b`, `c`, และ `d` ตามคิวฮะ ปกติชาวบ้านเค้ามักจะไม่ค่อยมานั่งหลังขดเขียนพิมพ์ค่านับลิสต์ช้อยส์กันโต้งๆ หรอก แต่เค้าจะพึ่งพาทริคอย่าง "command substitution" กันแทน ยกตัวอย่าง:

```bash
for i in $(seq 1 10); do
```

อันนี้จะเริ่มรันคำสั่ง `seq 1 10` ก่อนเลย (ซึ่งเป้าหมายมันมีไว้ปริ้นต์เศษเลขไล่ลามตั้งแต่ 1 ถีง 10 รวบยอดหมด) หลังจากนั้นก็จะเอาผลลัพธ์ตะกรันทั้งหมดที่ได้จากคำสั่งนั้น มายัดสวมรอยแทนตัวก้อน `$()` ไปซะดื้อๆ ส่งผลให้มันกลายร่างเป็น for loop แบบวิ่งเวียน 10 รอบนั่นเองฮะ ถ้าไปคุ้ยเจอในถิ่นโค้ดพวกจารึกเก่าๆ คุณอาจจะเจอตัวใช้สัญลักษณ์อิงแอบแบ็กทิก (อย่างเช่น ``for i in `seq 1 10`; do``) แทนที่จะเป็นทรง `$()` แต่เราขออวยไส้แตกเลยว่า แนะนำให้ฝังใจจดจำเป็นท่า `$()` ซะดีกว่านะฮะ เหตุผลหลักๆ ก็คือมันแอบออริจินัลเสกให้สามารถยัดสอดไส้ (nested) คำสั่งซ้อนพะรุงพะรังทับกันได้ง่ายดายลื่นปื๊ดนั่นเอง

ในขณะที่คุณ _สามารถ_ โชว์สกิลคีย์บอร์ดพิมพ์รัว shell scripts สายมาราธอนผ่านตัว prompt ได้โต้งๆ เลยก็จริง แต่โดยปกติชีวิตธรรมดามักจะเลือกเขียนดองยัดไว้ในไฟล์ `.sh` ซะมากกว่า ยกตัวอย่างให้เห็นภาพก็นี่เลย... บท script นี้มันพยายามจะวิ่งรันตัว test ของโปรแกรมสักตัวนึงไปเรื่อยๆ เข้าลูปแบบไม่มีวันตาย จนกว่าผลลัพธ์ที่ได้มันจะบึ้มพัง (fails), พอมันพังปุ๊บก็คอยงัดเอาเฉพาะบรรทัดที่มันพังออกมาแฉ แถมแอบซ้อนสั่งกระชาก CPU ไปรันกวนใน background พ่วงไปด้วยนะ (มีประโยชน์ไว้ลองวิชาวิเคราะห์ของพังจำลองเทส flaky tests ไรเงี้ยฮะ):

```bash
#!/bin/bash
set -euo pipefail

# Start CPU stress in background
stress --cpu 8 &
STRESS_PID=$!

# Setup log file
LOGFILE="test_runs_$(date +%s).log"
echo "Logging to $LOGFILE"

# Run tests until one fails
RUN=1
while cargo test my_test > "$LOGFILE" 2>&1; do
    echo "Run $RUN passed"
    ((RUN++))
done

# Cleanup and report
kill $STRESS_PID
echo "Test failed on run $RUN"
echo "Last 20 lines of output:"
tail -n 20 "$LOGFILE"
echo "Full log: $LOGFILE"
```

โพยข้างบนนี้มันแอบยัดไส้ลูกเล่นของใหม่ๆ แผลงๆ ไว้เพียบเลยนะ ซึ่งเราขอเอาท้าให้คุณไปลองงมดำน้ำขลุกแกะซุยศึกษาต่อก็จะคุ้มมาก เพราะลูกเล่นพวกนี้มันเวิร์กสุดๆ เวลาอยากหาช่องหลอมสร้าง shell invocations หรูๆ อาทิเช่น ปั้นงานให้ไปแอบวิ่งซุ่มซ่อนตัวอยู่ใน background (`&`) รันแบบตีคู่ขนานพร้อมกัน (concurrently) แง้มเปิดกระบวนท่าตุกติก [shell redirections](https://www.gnu.org/software/bash/manual/html_node/Redirections.html), รวมไปถึงเสพย์ลูกเล่น [arithmetic expansion](https://www.gnu.org/software/bash/manual/html_node/Arithmetic-Expansion.html) ได้อีกฮะ.

ขอพักเจียดเวลามางัดปมแกะปอกลอกในโค้ดสองบรรทัดบนสุดนั่นสักแพร็บนึงดีกว่า. แถวแรกนี่เราเรียกกันแบบหล่อๆ ว่า "shebang" -- ซึ่งหน้าตาแบบนี้คุณก็จะได้เจอะเจอได้ในโหมดหัวไฟล์ของตัวอื่นๆ ที่ไม่ได้เป็น shell scripts อยู่บ่อยๆ เหมือนกันฮะ กฎง่ายๆ คือ เวลาที่คุณรันไฟล์อะไรสักไฟล์ที่มีการเริ่มเปิดหัวร่ายเวทมนตร์ด้วย `#!/path` เข้าไป... ตัว shell เค้าจะรีบไปปลุกเรียกโปรแกรมตามตำแหน่งอ้างอิง `/path` นั้นขึ้นมา แล้วก็จัดแจงโยนเอาสารพัดข้อมูลในไฟล์นี้สุมเข้าไปป้อนให้เป็น input ต่อเลย ในมุมมองแบบฉบับ shell script อย่างเคสนี้ มันก็จะตีความกรายๆ ว่าเรากำลังโยนแผงเนื้อหา shell script ไปให้กับนาย `/bin/bash` ปิ้งย่างทำงานนั่นแหละครับ แต่คุณก็ยังสามารถดัดแปลงเน้นๆ เขียน Python scripts พร้อมกับห้อยเปิดตัว shebang เป็นท่อนว่า `/usr/bin/python` ได้สบายๆ แนบเนียนเช่นกันนะเออ!

บรรทัดที่สองนี่เป็นด่านกำแพงเหล็กที่เอาไว้บังคับข่มขู่ทำให้ bash มีความ "โหดตึง" (stricter) มีกฎเกณฑ์ขึ้นอีกนิดหน่อยฮะ และก็แอบปัดกวาดกับระเบิด footguns หลุมพรางบางอย่างออกให้เวลาที่เราหลอกเขียน shell scripts กัน คำสั่ง `set` จริงๆ เอาออปชันสารพัดใส่ต่อท้ายได้เป็นหางว่าว แต่แก่นกระซิบแบบสั้นๆ: ท่า `-e` ทำให้มั่นใจว่าถ้ามีคำสั่งตัวไหนพ่น failed แม้แต่บรรทัดเดียวละก็ ให้ script แม่งชิงจบปิดตายล่มวงไปไวๆ เลย; ตัว `-u` ออกระเบียบไว้ว่าถ้าดึงใช้ตัวแปรที่ยังไม่ได้เซ็ตค่าขึ้นเบิกมา ให้สอย script ขาดตายคางานทันที ไม่ยอมให้มันมาแกล้งถูไถอุปโลกน์ว่าเป็น empty string เหมือนปกติ; ส่วนตัว `-o pipefail` เป็นมุ้งดักอีกระดับ คือบอกว่าถ้ามีกัปตันโปรแกรมคนไหนในขบวนท่อ `|` ทำงานได้ล่มพังตาย ไม่รอ script ตีเหมาขบวนทั้งหมดเจ๊งวายวอดแอบชิงตายทิ้งกลางคันเหมือนกันเลย.

> การเขียน Shell programming เป็นยุทธจักรสายลึกที่มีความมึน เหมือนพวก programming language ค่ายไหนๆ แต่เตือนไว้ก่อนนะฮะ: ตัวแม่ bash แม่งพกปม gotchas หักเหลี่ยมล่อเป้าเก็บซ่อนไว้เยอะจัดๆ จนถึงขั้นที่มีแก๊งขุมทรัพย์งัดแงะเว็บบ้าเลือด[หลายๆ เจ้า](https://tldp.org/LDP/abs/html/gotchas.html) ถือกำเนิดขึ้นมาเอาไว้จัดรวบรวม[แฉลิสต์ตอแหลโชว์กาก](https://mywiki.wooledge.org/BashPitfalls) ของมันโดยเฉพาะเลย ผมขออวยเชียร์แกมบังคับให้คุณพึ่งพาจับดึง [shellcheck](https://www.shellcheck.net/) ถือหางมาคอยตรวจโค้ดให้มันบ่อยๆ เวลานั่งเขียน แถมโชคดีคือเดี๋ยวนี้มีพวกก๊วน LLMs เป็นอีกแรงตัวเทพคอยช่วยเขียนช่วย Debug คลำจับผิดให้เราได้ดีเลิศหรูหราเลยฮะ รวมไปถึงช่วยแปลทรานสเลตแปลงร่างให้มันกลายเป็นสายเลือด programming language ที่เป็น "ของจริง" (อย่างพวก Python) ในกรณีที่คุณรู้สึกว่าเห้ยไอโค้ด shell นี้แม่งเริ่มรุงรังชักจะงอแงเยิ่นเย้อยาวคุม bash ไม่อยู่แล้วอะ (ถ้าหลักๆ มันเด้งหลุดกรอบเกิน 100+ lines ขึ้นไปเงี้ย)

# Next steps

At this point you know your way around a shell enough to accomplish
basic tasks. You should be able to navigate around to find files of
interest and use the basic functionality of most programs. In the next
lecture, we will talk about how to perform and automate more complex
tasks using the shell and the many handy command-line programs out
there.

# Exercises

All classes in this course are accompanied by a series of exercises.
Some give you a specific task to do, while others are open-ended, like
"try using X and Y programs". We highly encourage you to try them out.

We have not written solutions for the exercises. If you are stuck on
anything in particular, feel free to post in `#missing-semester-forum`
on [Discord](https://ossu.dev/#community) or send us an email describing
what you've tried so far, and we will try to help you out. These
exercises will also likely work well as initial prompts in a
conversation with an LLM where you can interactively dive into the
topic. The real value in these exercises is the journey of discovering
the answers, not the answer itself. We encourage you to follow tangents
and ask "why" as you work through them, rather than just looking for the
shortest path to the solution.

1. For this course, you need to be using a Unix shell like Bash or ZSH. If
   you are on Linux or macOS, you don't have to do anything special. If you
   are on Windows, you need to make sure you are not running cmd.exe or
   PowerShell; you can use [Windows Subsystem for
   Linux](https://docs.microsoft.com/en-us/windows/wsl/) or a Linux virtual
   machine to use Unix-style command-line tools. To make sure you're running
   an appropriate shell, you can try the command `echo $SHELL`. If it says
   something like `/bin/bash` or `/usr/bin/zsh`, that means you're running
   the right program.

1. What does the `-l` flag to `ls` do? Run `ls -l /` and examine the output.
   What do the first 10 characters of each line mean? (Hint: `man ls`)

1. In the command `find ~/Downloads -type f -name "*.zip" -mtime +30`, the
   `*.zip` is a "glob". What is a glob? Create a test directory with some
   files and experiment with patterns like `ls *.txt`, `ls file?.txt`, and
   `ls {a,b,c}.txt`. See [Pattern
   Matching](https://www.gnu.org/software/bash/manual/html_node/Pattern-Matching.html)
   in the Bash manual.

1. What's the difference between `'single quotes'`, `"double quotes"`, and
   `$'ANSI quotes'`? Write a command that echoes a string containing a
   literal `$`, a `!`, and a newline character. See
   [Quoting](https://www.gnu.org/software/bash/manual/html_node/Quoting.html).

1. The shell has three standard streams: stdin (0), stdout (1), and stderr
   (2). Run `ls /nonexistent /tmp` and redirect stdout to one file and
   stderr to another. How would you redirect both to the same file? See
   [Redirections](https://www.gnu.org/software/bash/manual/html_node/Redirections.html).

1. `$?` holds the exit status of the last command (0 = success). `&&` runs
   the next command only if the previous succeeded; `||` runs it only if
   the previous failed. Write a one-liner that creates `/tmp/mydir` only if
   it doesn't already exist. See [Exit
   Status](https://www.gnu.org/software/bash/manual/html_node/Exit-Status.html).

1. Why does `cd` have to be built into the shell itself rather than a
   standalone program? (Hint: think about what a child process can and
   cannot affect in its parent.)

1. Write a script that takes a filename as an argument (`$1`) and checks
   whether the file exists using `test -f` or `[ -f ... ]`. It should print
   different messages depending on whether the file exists. See [Bash
   Conditional
   Expressions](https://www.gnu.org/software/bash/manual/html_node/Bash-Conditional-Expressions.html).

1. Save the script from the previous exercise to a file (e.g., `check.sh`).
   Try running it with `./check.sh somefile`. What happens? Now run
   `chmod +x check.sh` and try again. Why is this step necessary? (Hint:
   look at `ls -l check.sh` before and after the `chmod`.)

1. What happens if you add `-x` to the `set` flags in a script? Try it with
   a simple script and observe the output. See [The Set
   Builtin](https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html).

1. Write a command that copies a file to a backup with today's date in the
   filename (e.g., `notes.txt` → `notes_2026-01-12.txt`). (Hint: `$(date
+%Y-%m-%d)`). See [Command
   Substitution](https://www.gnu.org/software/bash/manual/html_node/Command-Substitution.html).

1. Modify the flaky test script from the lecture to accept the test command
   as an argument instead of hardcoding `cargo test my_test`. (Hint: `$1`
   or `$@`). See [Special
   Parameters](https://www.gnu.org/software/bash/manual/html_node/Special-Parameters.html).

1. Use pipes to find the 5 most common file extensions in your home
   directory. (Hint: combine `find`, `grep` or `sed` or `awk`, `sort`,
   `uniq -c`, and `head`.)

1. `xargs` converts lines from stdin into command arguments. Use `find` and
   `xargs` together (not `find -exec`) to find all `.sh` files in a
   directory and count the lines in each with `wc -l`. Bonus: make it
   handle filenames with spaces. (Hint: `-print0` and `-0`). See `man
xargs`.

1. Use `curl` to fetch the HTML of the course website
   (`https://missing.csail.mit.edu/`) and pipe it to `grep` to count how
   many lectures are listed. (Hint: look for a pattern that appears once
   per lecture; use `curl -s` to silence the progress output.)

1. [`jq`](https://jqlang.github.io/jq/) is a powerful tool for processing
   JSON data. Fetch the sample data at
   `https://microsoftedge.github.io/Demos/json-dummy-data/64KB.json` with
   `curl` and use `jq` to extract just the names of people whose version
   is greater than 6. (Hint: pipe to `jq .` first to see the structure;
   then try `jq '.[] | select(...) | .name'`)

1. `awk` can filter lines based on column values and manipulate output.
   For example, `awk '$3 ~ /pattern/ {$4=""; print}'` prints only lines
   where the third column matches `pattern`, while omitting the fourth
   column. Write an `awk` command that prints only lines where the second
   column is greater than 100, and swaps the first and third columns. Test
   with: `printf 'a 50 x\nb 150 y\nc 200 z\n'`

1. Dissect the SSH log pipeline from the lecture: what does each step do?
   Then build something similar to find your most-used shell commands from
   `~/.bash_history` (or `~/.zsh_history`).
